package parser

import (
	"fmt"
	"golox/lexer"
	"log"
)

type tokenStream struct {
	tokens  []lexer.Token
	current int
}

func (s *tokenStream) consume() lexer.Token {
	if s.isAtEnd() {
		panic("End Of file")
	}
	s.current++
	return s.tokens[s.current-1]
}

func (s *tokenStream) checkCurrent(tokenType lexer.TokenType, panicMessage string) lexer.Token {
	if s.isAtEnd() {
		log.Panicf("%s at end", panicMessage)
	}
	if s.tokens[s.current].TokenType != tokenType {
		log.Panicf("%s in line %d\n", panicMessage, s.tokens[s.current].Line)
	}
	return s.consume()
}

func (s *tokenStream) avance() {
	if s.isAtEnd() {
		return
	}
	s.current++
}

func (s tokenStream) getCurrent() lexer.Token {
	return s.tokens[s.current]
}

func (s tokenStream) isCurrentEqual(types ...lexer.TokenType) bool {
	if s.isAtEnd() {
		return false
	}
	for _, t := range types {
		if s.tokens[s.current].TokenType == t {
			return true
		}
	}
	return false
}

func (s tokenStream) isAtEnd() bool {
	return s.current >= len(s.tokens)
}

func (s tokenStream) getCurrentLine() int64 {
	return s.getCurrent().Line
}

// Parser creates a Abstract Syntax Tree from a buffer of Tokens generated by a lexer
type Parser struct {
	tokens *tokenStream
}

// NewParser creates your parser
func NewParser(tokens []lexer.Token) Parser {
	return Parser{&tokenStream{tokens, 0}}
}

// Parse you code
func (p Parser) Parse() (program []Stmt, err error) {
	defer func() {
		if r := recover(); r != nil {
			fmt.Println(r)
			program = nil
			err = fmt.Errorf("Parse Error")
		}
	}()
	var statements []Stmt
	for !p.tokens.isAtEnd() {
		statements = append(statements, p.declaration())
	}
	return statements, nil
}

func (p Parser) declaration() Stmt {
	if p.tokens.isCurrentEqual(lexer.TokenFun) {
		return p.funDeclaration()
	}
	if p.tokens.isCurrentEqual(lexer.TokenVar) {
		return p.varDeclaration()
	}
	return p.statement()
}

func (p Parser) funDeclaration() Stmt {
	p.tokens.avance() // consume fun
	funName := p.tokens.checkCurrent(lexer.TokenIdentifier, "Expected function name")
	p.tokens.checkCurrent(lexer.TokenLeftParen, "Expected '(' after function name")
	var argumentList []lexer.Token
	if !p.tokens.isCurrentEqual(lexer.TokenRightParen) {
		for {
			param := p.tokens.checkCurrent(lexer.TokenIdentifier, "Expected identifier inside function declaration argument list")
			argumentList = append(argumentList, param)
			if !p.tokens.isCurrentEqual(lexer.TokenComma) {
				break
			}
			p.tokens.avance() // consume comma
		}
	}
	p.tokens.checkCurrent(lexer.TokenRightParen, "Expected ')' after function name")
	body := p.block()
	return FunStmt{
		Name:          funName,
		ArgumentNames: argumentList,
		Body:          body,
	}
}

func (p Parser) varDeclaration() Stmt {
	p.tokens.avance()
	tokenName := p.tokens.checkCurrent(lexer.TokenIdentifier, "Expect variable name")
	var initializer Expr = LiteralExpr{
		Value: nil,
	}
	if p.tokens.isCurrentEqual(lexer.TokenEqual) {
		p.tokens.avance()
		initializer = p.expression()
	}
	p.tokens.checkCurrent(lexer.TokenSemicolon, "Expected ; after declaration")
	return VarStmt{
		Name:        tokenName,
		Initializer: initializer,
	}
}

func (p Parser) statement() Stmt {
	if p.tokens.isCurrentEqual(lexer.TokenPrint) {
		return p.printStmt()
	}
	if p.tokens.isCurrentEqual(lexer.TokenLeftBrace) {
		return BlockStmt{
			Statements: p.block(),
		}
	}
	if p.tokens.isCurrentEqual(lexer.TokenIf) {
		return p.ifStmt()
	}
	if p.tokens.isCurrentEqual(lexer.TokenWhile) {
		return p.whileStmt()
	}
	if p.tokens.isCurrentEqual(lexer.TokenFor) {
		return p.forStmt()
	}
	return p.exprStmt()
}

func (p Parser) forStmt() Stmt {
	p.tokens.avance() // consume for
	p.tokens.checkCurrent(lexer.TokenLeftParen, "Expected '(' after for")
	var initializer Stmt
	if p.tokens.isCurrentEqual(lexer.TokenSemicolon) {
		initializer = nil
		p.tokens.avance() // consume ;
	} else if p.tokens.isCurrentEqual(lexer.TokenVar) {
		initializer = p.varDeclaration()
	} else {
		initializer = p.exprStmt()
	}
	var condition Expr = nil
	if !p.tokens.isCurrentEqual(lexer.TokenSemicolon) {
		condition = p.expression()
	}
	p.tokens.checkCurrent(lexer.TokenSemicolon, "Expected ';' after for expression")
	var increment Expr = nil
	if !p.tokens.isCurrentEqual(lexer.TokenSemicolon) {
		increment = p.expression()
	}
	p.tokens.checkCurrent(lexer.TokenRightParen, "Expected ')' after for clause")
	body := p.statement()
	if increment != nil {
		body = BlockStmt{
			Statements: []Stmt{
				body,
				ExprStmt{increment},
			},
		}
	}
	if condition == nil {
		condition = LiteralExpr{true}
	}
	body = WhileStmt{condition, body}
	if initializer != nil {
		body = BlockStmt{
			Statements: []Stmt{
				initializer,
				body,
			},
		}
	}
	return body
}

func (p Parser) whileStmt() Stmt {
	p.tokens.avance() // consume while
	p.tokens.checkCurrent(lexer.TokenLeftParen, "Expected '(' after while")
	expr := p.expression()
	p.tokens.checkCurrent(lexer.TokenRightParen, "Expected ')' after while expression")
	stmt := p.statement()
	return WhileStmt{
		Expression: expr,
		Statement:  stmt,
	}
}

func (p Parser) ifStmt() Stmt {
	p.tokens.avance() // consume if
	p.tokens.checkCurrent(lexer.TokenLeftParen, "Expected '(' after if")
	expr := p.expression()
	p.tokens.checkCurrent(lexer.TokenRightParen, "Expected ')' after if expression")
	thenStmt := p.statement()
	var elseStmt Stmt = nil
	if p.tokens.isCurrentEqual(lexer.TokenElse) {
		p.tokens.avance() // consume else
		elseStmt = p.statement()
	}
	return IfStmt{
		Expression: expr,
		Then:       thenStmt,
		Else:       elseStmt,
	}
}

func (p Parser) block() []Stmt {
	var statements []Stmt
	p.tokens.avance() //consume {
	for !p.tokens.isAtEnd() && !p.tokens.isCurrentEqual(lexer.TokenRightBrace) {
		statements = append(statements, p.declaration())
	}
	p.tokens.checkCurrent(lexer.TokenRightBrace, "Expected '}' after block")
	return statements
}

func (p Parser) printStmt() Stmt {
	p.tokens.avance() // consume print
	expr := p.expression()
	p.tokens.checkCurrent(lexer.TokenSemicolon, "Expected ; after value")
	return PrintStmt{
		Value: expr,
	}
}

func (p Parser) exprStmt() Stmt {
	expr := p.expression()
	p.tokens.checkCurrent(lexer.TokenSemicolon, "Expected ; after expression")
	return ExprStmt{
		Expr: expr,
	}
}

func (p Parser) expression() Expr {
	return p.assigment()
}

func (p Parser) assigment() Expr {
	expr := p.logicOr()
	if p.tokens.isCurrentEqual(lexer.TokenEqual) {
		p.tokens.avance()
		value := p.assigment()
		if varExpr, ok := expr.(VarExpr); ok {
			return AssignExpr{
				Name:  varExpr.Name,
				Value: value,
			}
		}
		log.Panicf("Expected assigment in line %d", p.tokens.getCurrentLine())
	}
	return expr
}

func (p Parser) logicOr() Expr {
	expr := p.logicAnd()
	for p.tokens.isCurrentEqual(lexer.TokenOr) {
		expr = p.logicExpr(expr)
	}
	return expr
}

func (p Parser) logicAnd() Expr {
	expr := p.equality()
	for p.tokens.isCurrentEqual(lexer.TokenAnd) {
		expr = p.logicExpr(expr)
	}
	return expr
}

func (p Parser) logicExpr(left Expr) Expr {
	operator := p.tokens.consume()
	right := p.expression()
	return LogicExpr{
		Left:     left,
		Operator: operator,
		Right:    right,
	}
}

func (p Parser) equality() Expr {
	var expr Expr
	expr = p.comparison()
	for p.tokens.isCurrentEqual(lexer.TokenBangEqual, lexer.TokenEqualEqual) {
		operator := p.tokens.consume()
		right := p.comparison()
		expr = BinaryExpr{
			Right:    right,
			Operator: operator,
			Left:     expr,
		}
	}
	return expr
}

func (p Parser) comparison() Expr {
	var expr Expr
	expr = p.addition()
	for p.tokens.isCurrentEqual(lexer.TokenLess, lexer.TokenLessEqual, lexer.TokenGreater, lexer.TokenGreaterEqual) {
		comparator := p.tokens.consume()
		right := p.addition()
		expr = BinaryExpr{
			Right:    right,
			Operator: comparator,
			Left:     expr,
		}
	}
	return expr
}

func (p Parser) addition() Expr {
	var expr Expr
	expr = p.multiplication()
	for p.tokens.isCurrentEqual(lexer.TokenMinus, lexer.TokenPlus) {
		addition := p.tokens.consume()
		right := p.multiplication()
		expr = BinaryExpr{
			Right:    right,
			Operator: addition,
			Left:     expr,
		}
	}
	return expr
}

func (p Parser) multiplication() Expr {
	var expr Expr
	expr = p.unary()
	for p.tokens.isCurrentEqual(lexer.TokenStar, lexer.TokenSlash) {
		multiply := p.tokens.consume()
		right := p.unary()
		expr = BinaryExpr{
			Right:    right,
			Operator: multiply,
			Left:     expr,
		}
	}
	return expr
}

func (p Parser) unary() Expr {
	if p.tokens.isCurrentEqual(lexer.TokenBang, lexer.TokenMinus) {
		unary := p.tokens.consume()
		primary := p.primary()
		return UnaryExpr{
			Operator:   unary,
			Expression: primary,
		}
	}
	return p.call()
}

func (p Parser) call() Expr {
	calleeExpr := p.primary()
	for {
		if p.tokens.isCurrentEqual(lexer.TokenLeftParen) {
			calleeExpr = p.finishCall(calleeExpr)
		} else {
			break
		}
	}
	return calleeExpr
}

const ArgumentCountLimit int = 255

func (p Parser) finishCall(callee Expr) Expr {
	leftParen := p.tokens.getCurrent()
	p.tokens.avance() // consume left paren
	var arguments []Expr
	if !p.tokens.isCurrentEqual(lexer.TokenRightParen) {
		for {
			if len(arguments) >= ArgumentCountLimit {
				panic("Funciton call exceeds the argument limit!")
			}
			arguments = append(arguments, p.expression())
			if !p.tokens.isCurrentEqual(lexer.TokenComma) {
				break
			}
			p.tokens.avance() // consume comma
		}
	}
	p.tokens.checkCurrent(lexer.TokenRightParen, "Expected ')' after call arguments")
	return CallExpr{
		Callee:    callee,
		OpenParen: leftParen,
		Arguments: arguments,
	}
}

func (p Parser) primary() Expr {
	if p.tokens.isCurrentEqual(lexer.TokenTrue) {
		p.tokens.avance()
		return LiteralExpr{
			Value: true,
		}
	}
	if p.tokens.isCurrentEqual(lexer.TokenFalse) {
		p.tokens.avance()
		return LiteralExpr{
			Value: false,
		}
	}
	if p.tokens.isCurrentEqual(lexer.TokenNil) {
		p.tokens.avance()
		return LiteralExpr{
			Value: nil,
		}
	}
	if p.tokens.isCurrentEqual(lexer.TokenNumber, lexer.TokenString) {
		literal := p.tokens.consume()
		return LiteralExpr{
			Value: literal.Literal,
		}
	}
	if p.tokens.isCurrentEqual(lexer.TokenLeftParen) {
		p.tokens.avance()
		expr := p.expression()
		p.tokens.checkCurrent(lexer.TokenRightParen, "Expected ')'")
		return GroupingExpr{
			Expression: expr,
		}
	}
	if p.tokens.isCurrentEqual(lexer.TokenIdentifier) {
		name := p.tokens.getCurrent()
		p.tokens.avance()
		return VarExpr{
			Name: name,
		}
	}
	t := p.tokens.consume()
	log.Panicf("Unexpected token: %s\n", t.String())
	return nil
}
